package io.forward;

import util.cmds.PathCmds;
import util.data.RealtimeValues;
import io.Writable;
import io.netty.channel.EventLoopGroup;
import io.telnet.TelnetCodes;
import das.Commandable;
import org.apache.commons.lang3.math.NumberUtils;
import org.tinylog.Logger;
import org.w3c.dom.Element;
import util.xml.XMLfab;
import util.xml.XMLtools;
import worker.Datagram;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.*;
import java.util.concurrent.BlockingQueue;

public class ForwardPool implements Commandable {

    private final HashMap<String, PathForward> paths = new HashMap<>();
    private final BlockingQueue<Datagram> dQueue;
    private final Path settingsPath;
    private final RealtimeValues rtvals;
    private final EventLoopGroup nettyGroup;

    public ForwardPool(BlockingQueue<Datagram> dQueue, Path settingsPath, RealtimeValues rtvals,EventLoopGroup group){
        this.dQueue=dQueue;
        this.settingsPath=settingsPath;
        this.rtvals=rtvals;
        nettyGroup=group;
        readSettingsFromXML();
    }
    /* **************************************** G E N E R A L ************************************************** */
    /**
     * Read the forwards stored in the settings.xml
     */
    public void readSettingsFromXML() {

        var xmlOpt = XMLtools.readXML(settingsPath);
        if( xmlOpt.isEmpty()) {
            dQueue.add(Datagram.build("ForwardPool -> Failed to read xml at "+settingsPath).label("fail"));
            return;
        }
        /* Figure out the paths? */
        Logger.info("Loading paths...");
        readPathsFromXML();
        Logger.info("Finished loading Forwardpool");
    }

    @Override
    public String replyToCommand(String[] request, Writable wr, boolean html) {
        boolean ok;

        // Regular ones
        switch (request[0]) {
            // Path
            case "paths", "pf" -> {
                return replyToPathCmd(request[1], wr, html);
            }
            case "path" -> {
                var p = paths.get(request[1]);
                if (p == null)
                    return "No such path (yet): " + request[1];
                p.addTarget(wr);
                return "Request received.";
            }
            default -> {
                return "unknown command: " + request[0] + ":" + request[1];
            }
        }
    }

    @Override
    public boolean removeWritable( Writable wr) {
        paths.values().forEach( p -> p.removeTarget(wr));
        return false;
    }
    /* ******************************************** P A T H ******************************************************** */
    public String replyToPathCmd(String cmd, Writable wr, boolean html ){
        var cmds =cmd.split(",");

        String cyan = html?"":TelnetCodes.TEXT_CYAN;
        String green=html?"":TelnetCodes.TEXT_GREEN;
        String reg=html?"":TelnetCodes.TEXT_YELLOW+TelnetCodes.UNDERLINE_OFF;

        XMLfab fab;
        switch(cmds[0]){
            case "?":
                StringJoiner help = new StringJoiner("\r\n");
                help.add(TelnetCodes.TEXT_RESET+TelnetCodes.TEXT_ORANGE+"Notes"+reg)
                .add(" Paths are used to combine multiple different forwards in a single structure, this allows for a")
                .add(" lot of attributes to be either generated by dcafs fe. src or omitted (id's) which reduces")
                .add(" the amount of xml the user needs to write.");
                help.add("").add(cyan+"Add/build new paths"+reg)
                .add(green+" pf:addpath/add,id,src "+reg+"-> Add a path with the given id and src")
                .add(green+" pf:addfile,id,src "+reg+"-> Add a path file with the given id and src");
                help.add("").add(cyan+"Other"+reg)
                .add(green+" pf:reload,id "+reg+"-> reload the path with the given id")
                .add(green+" pf:readpath,id,path "+reg+"-> Add a path using a path xml")
                .add(green+" pf:list "+reg+"-> List all the currently loaded paths")
                .add(green+" pf:debug,id,stepnr/stepid "+reg+"-> Request the data from a single step in the path (nr:0=first; -1=custom src)");
                return help.toString();
            case "reload":
            case "reloadall":
                if( cmds.length==1 || cmds[0].endsWith("all")) {
                    readPathsFromXML();
                    return "All paths reloaded.";
                }
                var ele = XMLfab.withRoot(settingsPath,"dcafs","paths")
                        .getChild("path","id",cmds[1]);
                if(ele.isEmpty())
                    return "No such path "+cmds[1];
                var result =paths.get(cmds[1]).readFromXML(ele.get(),settingsPath.getParent());
                return result.isEmpty()?"Path reloaded":result;
            case "readfile":

                return "File reading added (todo)";
            case "addfile":
                if( cmds.length<2) {
                    return "To few arguments, expected pf:addfile,id,src (src is optional)";
                }

                try {
                    Files.createDirectories( settingsPath.getParent().resolve("paths") );
                } catch (IOException e) {
                    Logger.error(e);
                }

                var p = settingsPath.getParent().resolve("paths").resolve(cmds[1]+".xml");
                XMLfab.withRoot(p,"dcafs")
                        .addParentToRoot("path")
                            .attr("id",cmds[1])
                            .attr("delimiter",",")
                        .build();

                XMLfab.withRoot(settingsPath,"dcafs","paths")
                        .selectOrAddChildAsParent("path","id",cmds[1])
                        .attr("src",cmds.length>2?cmds[2]:"")
                        .attr("delimiter",",")
                        .attr("import","paths"+ File.separator+cmds[1]+".xml")
                        .build();
                dQueue.add( Datagram.system("gens:reload") );
                readPathsFromXML();
                return "New path file added and reloaded";
            case "addpath": case "add": case "new":
                if( cmds.length<2) {
                    return "To few arguments, expected pf:add,id,src";
                }
                XMLfab.withRoot(settingsPath,"dcafs","paths")
                        .selectOrAddChildAsParent("path","id",cmds[1])
                            .attr("src",cmds.length>2?cmds[2]:"")
                            .attr("delimiter",",")
                            .build();

                if( cmds.length==3) {
                    if( !cmds[2].contains(":")){
                        return "No valid source  given, need to contain a :";
                    }
                    PathForward path = new PathForward(rtvals,dQueue,nettyGroup);
                    path.setWorkPath(settingsPath.getParent());
                    if( cmds[2].startsWith("file:")) {
                        fab = XMLfab.withRoot(settingsPath, "dcafs", "paths")
                                .selectOrAddChildAsParent("path", "id", cmds[1])
                                .addChild("customsrc", cmds[2]).attr("type", "file").attr("interval", "1s");
                        fab.build();
                        path.readFromXML( fab.getCurrentElement(),settingsPath.getParent() );
                    }else{
                        path.setSrc(cmds[2]);
                    }
                    paths.put(cmds[1],path);
                    return "Path added";
                }else if( cmds.length<3){
                    return "Not enough arguments, need paths:addpath,id,src";
                }
            case "remove":
                if( cmds.length!=2)
                    return "Missing id";
                if( XMLfab.withRoot(settingsPath, "dcafs", "paths").removeChild("path","id",cmds[1]) ){
                    return "Path removed";
                }
                return "No such path "+cmds[1];
            case "clear":
                XMLfab.withRoot(settingsPath, "dcafs", "paths").clearChildren().build();
                readPathsFromXML();
                return "Paths cleared";
            case "stop":
                paths.values().forEach( pf -> pf.removeTarget(wr) );
                return "Stopped sending to "+wr.id();
            case "list":
                StringJoiner join = new StringJoiner(html?"<br>":"\r\n");
                join.setEmptyValue("No paths yet");
                paths.forEach((key, value) -> {
                    String src=key+" src: "+value.src();
                    join.add(TelnetCodes.TEXT_GREEN + "Path: " + src + TelnetCodes.TEXT_YELLOW).add(value.toString()).add("");
                });
                return join.toString();
            case "debug":
                if( cmds.length!=3)
                    return "Incorrect number of arguments, needs to be path:debug,pathid,stepnr/stepid (from 0 or -1 for customsrc)";
                var pp = paths.get(cmds[1]);
                if( pp==null)
                    return "No such path: "+cmds[1];
                int nr = NumberUtils.toInt(cmds[2],-2);

                if( wr==null)
                    return "No valid writable";
                if( nr==-2)
                    return pp.debugStep(cmds[2],wr);
                return pp.debugStep(nr,wr);
            default:
                var res = PathCmds.replyToCommand(cmd,html,settingsPath);
                // Reload the path
                var pEle = XMLfab.withRoot(settingsPath,"dcafs","paths")
                                .getChild("path","id",cmds[0]);
                if(!res.startsWith("!")) { // If cmd worked
                    if (!pEle.isEmpty() ) { // If an existing path was altered
                        paths.get(cmds[0]).readFromXML(pEle.get(), settingsPath.getParent());
                    }else if( cmds[1].equalsIgnoreCase("delete")){ // meaning the path was removed from xml, remove it from paths
                        removePath(cmds[0]);
                    }
                }
                // Add some color based on good or bad result
                if( res.startsWith("!") || res.startsWith("unknown"))
                    return TelnetCodes.TEXT_ORANGE + res + reg;
                return TelnetCodes.TEXT_GREEN + res + reg;
        }
    }
    private void removePath(String id){
        var p = paths.get(id);
        if( p!=null){
            p.clearStores(); // reset the used stores
            paths.remove(id);
        }
    }
    public void readPathsFromXML(){
        // Reset the rtval stores
        clearStores();

        // From the paths section
        XMLfab.getRootChildren(settingsPath,"dcafs","paths","path").forEach(
                pathEle -> {
                    PathForward path = new PathForward(rtvals,dQueue,nettyGroup);
                    path.readFromXML( pathEle,settingsPath.getParent() );
                    var p = paths.get(path.getID());
                    if( p!=null) {
                      //  p.lastStep().ifPresent( path::addTarget);
                        p.stop();
                        paths.remove(p.getID());
                    }
                    paths.put(path.getID(),path);
                }
        );

        // From the streams section
        XMLfab.getRootChildren(settingsPath,"dcafs","streams","stream").stream()
                .filter( e -> XMLtools.hasChildByTag(e,"path")) // Only those with a path node
                .map( e -> XMLtools.getFirstChildByTag(e,"path").get())
                .forEach(
                    pathEle -> {
                        PathForward path = new PathForward(rtvals,dQueue,nettyGroup);
                        var parentId = XMLtools.getStringAttribute((Element) pathEle.getParentNode(), "id", "");
                        // The functionality to import a path, relies on an attribute while this will be a content instead but may be...
                        if( !pathEle.hasAttribute("import")) {
                            var importPath = pathEle.getTextContent();
                            if (importPath.isEmpty()) {

                                Logger.error("Empty content in path node for " + parentId);
                                return;
                            }
                            pathEle.setAttribute("import", pathEle.getTextContent());
                            pathEle.setTextContent("");
                        }
                        pathEle.setAttribute("src","raw:"+parentId);
                        path.readFromXML(pathEle,settingsPath.getParent());
                    });
    }
    private void clearStores(){
        paths.values().forEach(PathForward::clearStores);
    }
}
